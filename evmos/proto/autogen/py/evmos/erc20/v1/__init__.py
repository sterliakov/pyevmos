# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: evmos/erc20/v1/erc20.proto, evmos/erc20/v1/genesis.proto, evmos/erc20/v1/query.proto, evmos/erc20/v1/tx.proto
# plugin: python-betterproto
# This file has been @generated
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ....cosmos.bank import v1beta1 as ___cosmos_bank_v1_beta1__
from ....cosmos.base import v1beta1 as ___cosmos_base_v1_beta1__
from ....cosmos.base.query import v1beta1 as ___cosmos_base_query_v1_beta1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class Owner(betterproto.Enum):
    """Owner enumerates the ownership of a ERC20 contract."""

    OWNER_UNSPECIFIED = 0
    """OWNER_UNSPECIFIED defines an invalid/undefined owner."""

    OWNER_MODULE = 1
    """OWNER_MODULE erc20 is owned by the erc20 module account."""

    OWNER_EXTERNAL = 2
    """EXTERNAL erc20 is owned by an external account."""


@dataclass(eq=False, repr=False)
class TokenPair(betterproto.Message):
    """
    TokenPair defines an instance that records a pairing consisting of a native
     Cosmos Coin and an ERC20 token address.
    """

    erc20_address: str = betterproto.string_field(1)
    """address of ERC20 contract token"""

    denom: str = betterproto.string_field(2)
    """cosmos base denomination to be mapped to"""

    enabled: bool = betterproto.bool_field(3)
    """shows token mapping enable status"""

    contract_owner: 'Owner' = betterproto.enum_field(4)
    """ERC20 owner address ENUM (0 invalid, 1 ModuleAccount, 2 external address)"""


@dataclass(eq=False, repr=False)
class RegisterCoinProposal(betterproto.Message):
    """
    RegisterCoinProposal is a gov Content type to register a token pair for a
    native Cosmos coin.
    """

    title: str = betterproto.string_field(1)
    """title of the proposal"""

    description: str = betterproto.string_field(2)
    """proposal description"""

    metadata: '___cosmos_bank_v1_beta1__.Metadata' = betterproto.message_field(3)
    """metadata of the native Cosmos coin"""


@dataclass(eq=False, repr=False)
class RegisterErc20Proposal(betterproto.Message):
    """
    RegisterERC20Proposal is a gov Content type to register a token pair for an
    ERC20 token
    """

    title: str = betterproto.string_field(1)
    """title of the proposal"""

    description: str = betterproto.string_field(2)
    """proposal description"""

    erc20_address: str = betterproto.string_field(3)
    """contract address of ERC20 token"""


@dataclass(eq=False, repr=False)
class ToggleTokenConversionProposal(betterproto.Message):
    """
    ToggleTokenConversionProposal is a gov Content type to toggle the conversion
    of a token pair.
    """

    title: str = betterproto.string_field(1)
    """title of the proposal"""

    description: str = betterproto.string_field(2)
    """proposal description"""

    token: str = betterproto.string_field(3)
    """
    token identifier can be either the hex contract address of the ERC20 or the
    Cosmos base denomination
    """


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the module's genesis state."""

    params: 'Params' = betterproto.message_field(1)
    """module parameters"""

    token_pairs: List['TokenPair'] = betterproto.message_field(2)
    """registered token pairs"""


@dataclass(eq=False, repr=False)
class Params(betterproto.Message):
    """Params defines the erc20 module params"""

    enable_erc20: bool = betterproto.bool_field(1)
    """parameter to enable the conversion of Cosmos coins <--> ERC20 tokens."""

    enable_evm_hook: bool = betterproto.bool_field(2)
    """
    parameter to enable the EVM hook that converts an ERC20 token to a Cosmos
    Coin by transferring the Tokens through a MsgEthereumTx to the
    ModuleAddress Ethereum address.
    """


@dataclass(eq=False, repr=False)
class QueryTokenPairsRequest(betterproto.Message):
    """
    QueryTokenPairsRequest is the request type for the Query/TokenPairs RPC
    method.
    """

    pagination: '___cosmos_base_query_v1_beta1__.PageRequest' = (
        betterproto.message_field(1)
    )
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryTokenPairsResponse(betterproto.Message):
    """
    QueryTokenPairsResponse is the response type for the Query/TokenPairs RPC
    method.
    """

    token_pairs: List['TokenPair'] = betterproto.message_field(1)
    pagination: '___cosmos_base_query_v1_beta1__.PageResponse' = (
        betterproto.message_field(2)
    )
    """pagination defines the pagination in the response."""


@dataclass(eq=False, repr=False)
class QueryTokenPairRequest(betterproto.Message):
    """QueryTokenPairRequest is the request type for the Query/TokenPair RPC method."""

    token: str = betterproto.string_field(1)
    """
    token identifier can be either the hex contract address of the ERC20 or the
    Cosmos base denomination
    """


@dataclass(eq=False, repr=False)
class QueryTokenPairResponse(betterproto.Message):
    """
    QueryTokenPairResponse is the response type for the Query/TokenPair RPC
    method.
    """

    token_pair: 'TokenPair' = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryParamsRequest(betterproto.Message):
    """QueryParamsRequest is the request type for the Query/Params RPC method."""

    pass


@dataclass(eq=False, repr=False)
class QueryParamsResponse(betterproto.Message):
    """
    QueryParamsResponse is the response type for the Query/Params RPC
    method.
    """

    params: 'Params' = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class MsgConvertCoin(betterproto.Message):
    """MsgConvertCoin defines a Msg to convert a native Cosmos coin to a ERC20 token"""

    coin: '___cosmos_base_v1_beta1__.Coin' = betterproto.message_field(1)
    """
    Cosmos coin which denomination is registered in a token pair. The coin
    amount defines the amount of coins to convert.
    """

    receiver: str = betterproto.string_field(2)
    """recipient hex address to receive ERC20 token"""

    sender: str = betterproto.string_field(3)
    """cosmos bech32 address from the owner of the given Cosmos coins"""


@dataclass(eq=False, repr=False)
class MsgConvertCoinResponse(betterproto.Message):
    """MsgConvertCoinResponse returns no fields"""

    pass


@dataclass(eq=False, repr=False)
class MsgConvertErc20(betterproto.Message):
    """
    MsgConvertERC20 defines a Msg to convert a ERC20 token to a native Cosmos
    coin.
    """

    contract_address: str = betterproto.string_field(1)
    """ERC20 token contract address registered in a token pair"""

    amount: str = betterproto.string_field(2)
    """amount of ERC20 tokens to convert"""

    receiver: str = betterproto.string_field(3)
    """bech32 address to receive native Cosmos coins"""

    sender: str = betterproto.string_field(4)
    """sender hex address from the owner of the given ERC20 tokens"""


@dataclass(eq=False, repr=False)
class MsgConvertErc20Response(betterproto.Message):
    """MsgConvertERC20Response returns no fields"""

    pass


class QueryStub(betterproto.ServiceStub):
    async def token_pairs(
        self,
        query_token_pairs_request: 'QueryTokenPairsRequest',
        *,
        timeout: Optional[float] = None,
        deadline: Optional['Deadline'] = None,
        metadata: Optional['MetadataLike'] = None
    ) -> 'QueryTokenPairsResponse':
        return await self._unary_unary(
            '/evmos.erc20.v1.Query/TokenPairs',
            query_token_pairs_request,
            QueryTokenPairsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def token_pair(
        self,
        query_token_pair_request: 'QueryTokenPairRequest',
        *,
        timeout: Optional[float] = None,
        deadline: Optional['Deadline'] = None,
        metadata: Optional['MetadataLike'] = None
    ) -> 'QueryTokenPairResponse':
        return await self._unary_unary(
            '/evmos.erc20.v1.Query/TokenPair',
            query_token_pair_request,
            QueryTokenPairResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def params(
        self,
        query_params_request: 'QueryParamsRequest',
        *,
        timeout: Optional[float] = None,
        deadline: Optional['Deadline'] = None,
        metadata: Optional['MetadataLike'] = None
    ) -> 'QueryParamsResponse':
        return await self._unary_unary(
            '/evmos.erc20.v1.Query/Params',
            query_params_request,
            QueryParamsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class MsgStub(betterproto.ServiceStub):
    async def convert_coin(
        self,
        msg_convert_coin: 'MsgConvertCoin',
        *,
        timeout: Optional[float] = None,
        deadline: Optional['Deadline'] = None,
        metadata: Optional['MetadataLike'] = None
    ) -> 'MsgConvertCoinResponse':
        return await self._unary_unary(
            '/evmos.erc20.v1.Msg/ConvertCoin',
            msg_convert_coin,
            MsgConvertCoinResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def convert_erc20(
        self,
        *,
        timeout: Optional[float] = None,
        deadline: Optional['Deadline'] = None,
        metadata: Optional['MetadataLike'] = None
    ) -> 'MsgConvertErc20Response':
        return await self._unary_unary(
            '/evmos.erc20.v1.Msg/ConvertERC20',
            msg_convert_erc20,
            MsgConvertErc20Response,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class QueryBase(ServiceBase):
    async def token_pairs(
        self, query_token_pairs_request: 'QueryTokenPairsRequest'
    ) -> 'QueryTokenPairsResponse':
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def token_pair(
        self, query_token_pair_request: 'QueryTokenPairRequest'
    ) -> 'QueryTokenPairResponse':
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def params(
        self, query_params_request: 'QueryParamsRequest'
    ) -> 'QueryParamsResponse':
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_token_pairs(
        self,
        stream: 'grpclib.server.Stream[QueryTokenPairsRequest, QueryTokenPairsResponse]',
    ) -> None:
        request = await stream.recv_message()
        response = await self.token_pairs(request)
        await stream.send_message(response)

    async def __rpc_token_pair(
        self,
        stream: 'grpclib.server.Stream[QueryTokenPairRequest, QueryTokenPairResponse]',
    ) -> None:
        request = await stream.recv_message()
        response = await self.token_pair(request)
        await stream.send_message(response)

    async def __rpc_params(
        self, stream: 'grpclib.server.Stream[QueryParamsRequest, QueryParamsResponse]'
    ) -> None:
        request = await stream.recv_message()
        response = await self.params(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            '/evmos.erc20.v1.Query/TokenPairs': grpclib.const.Handler(
                self.__rpc_token_pairs,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryTokenPairsRequest,
                QueryTokenPairsResponse,
            ),
            '/evmos.erc20.v1.Query/TokenPair': grpclib.const.Handler(
                self.__rpc_token_pair,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryTokenPairRequest,
                QueryTokenPairResponse,
            ),
            '/evmos.erc20.v1.Query/Params': grpclib.const.Handler(
                self.__rpc_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryParamsRequest,
                QueryParamsResponse,
            ),
        }


class MsgBase(ServiceBase):
    async def convert_coin(
        self, msg_convert_coin: 'MsgConvertCoin'
    ) -> 'MsgConvertCoinResponse':
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def convert_erc20(self) -> 'MsgConvertErc20Response':
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_convert_coin(
        self, stream: 'grpclib.server.Stream[MsgConvertCoin, MsgConvertCoinResponse]'
    ) -> None:
        request = await stream.recv_message()
        response = await self.convert_coin(request)
        await stream.send_message(response)

    async def __rpc_convert_erc20(
        self, stream: 'grpclib.server.Stream[MsgConvertErc20, MsgConvertErc20Response]'
    ) -> None:
        request = await stream.recv_message()
        response = await self.convert_erc20(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            '/evmos.erc20.v1.Msg/ConvertCoin': grpclib.const.Handler(
                self.__rpc_convert_coin,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgConvertCoin,
                MsgConvertCoinResponse,
            ),
            '/evmos.erc20.v1.Msg/ConvertERC20': grpclib.const.Handler(
                self.__rpc_convert_erc20,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgConvertErc20,
                MsgConvertErc20Response,
            ),
        }
