# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: evmos/erc20/v1/erc20.proto, evmos/erc20/v1/genesis.proto, evmos/erc20/v1/query.proto, evmos/erc20/v1/tx.proto
# plugin: python-betterproto
# This file has been @generated
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ....cosmos.bank import v1beta1 as ___cosmos_bank_v1_beta1__
from ....cosmos.base import v1beta1 as ___cosmos_base_v1_beta1__
from ....cosmos.base.query import v1beta1 as ___cosmos_base_query_v1_beta1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class Owner(betterproto.Enum):
    """Owner enumerates the ownership of a ERC20 contract."""

    OWNER_UNSPECIFIED = 0
    """OWNER_UNSPECIFIED defines an invalid/undefined owner."""

    OWNER_MODULE = 1
    """OWNER_MODULE erc20 is owned by the erc20 module account."""

    OWNER_EXTERNAL = 2
    """EXTERNAL erc20 is owned by an external account."""


@dataclass(eq=False, repr=False)
class TokenPair(betterproto.Message):
    """
    TokenPair defines an instance that records a pairing consisting of a native
     Cosmos Coin and an ERC20 token address.
    """

    erc20_address: str = betterproto.string_field(1)
    """address of ERC20 contract token"""

    denom: str = betterproto.string_field(2)
    """cosmos base denomination to be mapped to"""

    enabled: bool = betterproto.bool_field(3)
    """shows token mapping enable status"""

    contract_owner: "Owner" = betterproto.enum_field(4)
    """ERC20 owner address ENUM (0 invalid, 1 ModuleAccount, 2 external address)"""


@dataclass(eq=False, repr=False)
class RegisterCoinProposal(betterproto.Message):
    """
    RegisterCoinProposal is a gov Content type to register a token pair for a
    native Cosmos coin.
    """

    title: str = betterproto.string_field(1)
    """title of the proposal"""

    description: str = betterproto.string_field(2)
    """proposal description"""

    metadata: "___cosmos_bank_v1_beta1__.Metadata" = betterproto.message_field(3)
    """metadata of the native Cosmos coin"""


@dataclass(eq=False, repr=False)
class RegisterErc20Proposal(betterproto.Message):
    """
    RegisterERC20Proposal is a gov Content type to register a token pair for an
    ERC20 token
    """

    title: str = betterproto.string_field(1)
    """title of the proposal"""

    description: str = betterproto.string_field(2)
    """proposal description"""

    erc20_address: str = betterproto.string_field(3)
    """contract address of ERC20 token"""


@dataclass(eq=False, repr=False)
class ToggleTokenConversionProposal(betterproto.Message):
    """
    ToggleTokenConversionProposal is a gov Content type to toggle the conversion
    of a token pair.
    """

    title: str = betterproto.string_field(1)
    """title of the proposal"""

    description: str = betterproto.string_field(2)
    """proposal description"""

    token: str = betterproto.string_field(3)
    """
    token identifier can be either the hex contract address of the ERC20 or the
    Cosmos base denomination
    """


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the module's genesis state."""

    params: "Params" = betterproto.message_field(1)
    """module parameters"""

    token_pairs: List["TokenPair"] = betterproto.message_field(2)
    """registered token pairs"""


@dataclass(eq=False, repr=False)
class Params(betterproto.Message):
    """Params defines the erc20 module params"""

    enable_erc20: bool = betterproto.bool_field(1)
    """parameter to enable the conversion of Cosmos coins <--> ERC20 tokens."""

    enable_evm_hook: bool = betterproto.bool_field(2)
    """
    parameter to enable the EVM hook that converts an ERC20 token to a Cosmos
    Coin by transferring the Tokens through a MsgEthereumTx to the
    ModuleAddress Ethereum address.
    """


@dataclass(eq=False, repr=False)
class QueryTokenPairsRequest(betterproto.Message):
    """
    QueryTokenPairsRequest is the request type for the Query/TokenPairs RPC
    method.
    """

    pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryTokenPairsResponse(betterproto.Message):
    """
    QueryTokenPairsResponse is the response type for the Query/TokenPairs RPC
    method.
    """

    token_pairs: List["TokenPair"] = betterproto.message_field(1)
    pagination: "___cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )
    """pagination defines the pagination in the response."""


@dataclass(eq=False, repr=False)
class QueryTokenPairRequest(betterproto.Message):
    """QueryTokenPairRequest is the request type for the Query/TokenPair RPC method."""

    token: str = betterproto.string_field(1)
    """
    token identifier can be either the hex contract address of the ERC20 or the
    Cosmos base denomination
    """


@dataclass(eq=False, repr=False)
class QueryTokenPairResponse(betterproto.Message):
    """
    QueryTokenPairResponse is the response type for the Query/TokenPair RPC
    method.
    """

    token_pair: "TokenPair" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryParamsRequest(betterproto.Message):
    """QueryParamsRequest is the request type for the Query/Params RPC method."""

    pass


@dataclass(eq=False, repr=False)
class QueryParamsResponse(betterproto.Message):
    """
    QueryParamsResponse is the response type for the Query/Params RPC
    method.
    """

    params: "Params" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class MsgConvertCoin(betterproto.Message):
    """MsgConvertCoin defines a Msg to convert a native Cosmos coin to a ERC20 token"""

    coin: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(1)
    """
    Cosmos coin which denomination is registered in a token pair. The coin
    amount defines the amount of coins to convert.
    """

    receiver: str = betterproto.string_field(2)
    """recipient hex address to receive ERC20 token"""

    sender: str = betterproto.string_field(3)
    """cosmos bech32 address from the owner of the given Cosmos coins"""


@dataclass(eq=False, repr=False)
class MsgConvertCoinResponse(betterproto.Message):
    """MsgConvertCoinResponse returns no fields"""

    pass


@dataclass(eq=False, repr=False)
class MsgConvertErc20(betterproto.Message):
    """
    MsgConvertERC20 defines a Msg to convert a ERC20 token to a native Cosmos
    coin.
    """

    contract_address: str = betterproto.string_field(1)
    """ERC20 token contract address registered in a token pair"""

    amount: str = betterproto.string_field(2)
    """amount of ERC20 tokens to convert"""

    receiver: str = betterproto.string_field(3)
    """bech32 address to receive native Cosmos coins"""

    sender: str = betterproto.string_field(4)
    """sender hex address from the owner of the given ERC20 tokens"""


@dataclass(eq=False, repr=False)
class MsgConvertErc20Response(betterproto.Message):
    """MsgConvertERC20Response returns no fields"""

    pass


class QueryStub(betterproto.ServiceStub):
    async def token_pairs(
        self,
        query_token_pairs_request: "QueryTokenPairsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "QueryTokenPairsResponse":
        return await self._unary_unary(
            "/evmos.erc20.v1.Query/TokenPairs",
            query_token_pairs_request,
            QueryTokenPairsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def token_pair(
        self,
        query_token_pair_request: "QueryTokenPairRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "QueryTokenPairResponse":
        return await self._unary_unary(
            "/evmos.erc20.v1.Query/TokenPair",
            query_token_pair_request,
            QueryTokenPairResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def params(
        self,
        query_params_request: "QueryParamsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "QueryParamsResponse":
        return await self._unary_unary(
            "/evmos.erc20.v1.Query/Params",
            query_params_request,
            QueryParamsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class MsgStub(betterproto.ServiceStub):
    async def convert_coin(
        self,
        msg_convert_coin: "MsgConvertCoin",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "MsgConvertCoinResponse":
        return await self._unary_unary(
            "/evmos.erc20.v1.Msg/ConvertCoin",
            msg_convert_coin,
            MsgConvertCoinResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def convert_erc20(
        self,
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "MsgConvertErc20Response":
        return await self._unary_unary(
            "/evmos.erc20.v1.Msg/ConvertERC20",
            msg_convert_erc20,
            MsgConvertErc20Response,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class QueryBase(ServiceBase):
    async def token_pairs(
        self, query_token_pairs_request: "QueryTokenPairsRequest"
    ) -> "QueryTokenPairsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def token_pair(
        self, query_token_pair_request: "QueryTokenPairRequest"
    ) -> "QueryTokenPairResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def params(
        self, query_params_request: "QueryParamsRequest"
    ) -> "QueryParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_token_pairs(
        self,
        stream: "grpclib.server.Stream[QueryTokenPairsRequest, QueryTokenPairsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.token_pairs(request)
        await stream.send_message(response)

    async def __rpc_token_pair(
        self,
        stream: "grpclib.server.Stream[QueryTokenPairRequest, QueryTokenPairResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.token_pair(request)
        await stream.send_message(response)

    async def __rpc_params(
        self, stream: "grpclib.server.Stream[QueryParamsRequest, QueryParamsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.params(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/evmos.erc20.v1.Query/TokenPairs": grpclib.const.Handler(
                self.__rpc_token_pairs,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryTokenPairsRequest,
                QueryTokenPairsResponse,
            ),
            "/evmos.erc20.v1.Query/TokenPair": grpclib.const.Handler(
                self.__rpc_token_pair,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryTokenPairRequest,
                QueryTokenPairResponse,
            ),
            "/evmos.erc20.v1.Query/Params": grpclib.const.Handler(
                self.__rpc_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryParamsRequest,
                QueryParamsResponse,
            ),
        }


class MsgBase(ServiceBase):
    async def convert_coin(
        self, msg_convert_coin: "MsgConvertCoin"
    ) -> "MsgConvertCoinResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def convert_erc20(self) -> "MsgConvertErc20Response":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_convert_coin(
        self, stream: "grpclib.server.Stream[MsgConvertCoin, MsgConvertCoinResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.convert_coin(request)
        await stream.send_message(response)

    async def __rpc_convert_erc20(
        self, stream: "grpclib.server.Stream[MsgConvertErc20, MsgConvertErc20Response]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.convert_erc20(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/evmos.erc20.v1.Msg/ConvertCoin": grpclib.const.Handler(
                self.__rpc_convert_coin,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgConvertCoin,
                MsgConvertCoinResponse,
            ),
            "/evmos.erc20.v1.Msg/ConvertERC20": grpclib.const.Handler(
                self.__rpc_convert_erc20,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgConvertErc20,
                MsgConvertErc20Response,
            ),
        }
