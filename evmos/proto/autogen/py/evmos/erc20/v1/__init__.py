# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: evmos/erc20/v1/erc20.proto, evmos/erc20/v1/events.proto, evmos/erc20/v1/genesis.proto, evmos/erc20/v1/query.proto, evmos/erc20/v1/tx.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ....cosmos.bank import v1beta1 as ___cosmos_bank_v1_beta1__
from ....cosmos.base import v1beta1 as ___cosmos_base_v1_beta1__
from ....cosmos.base.query import v1beta1 as ___cosmos_base_query_v1_beta1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class Owner(betterproto.Enum):
    """Owner enumerates the ownership of a ERC20 contract."""

    OWNER_UNSPECIFIED = 0
    """OWNER_UNSPECIFIED defines an invalid/undefined owner."""

    OWNER_MODULE = 1
    """OWNER_MODULE - erc20 is owned by the erc20 module account."""

    OWNER_EXTERNAL = 2
    """OWNER_EXTERNAL - erc20 is owned by an external account."""


@dataclass(eq=False, repr=False)
class TokenPair(betterproto.Message):
    """
    TokenPair defines an instance that records a pairing consisting of a native
    Cosmos Coin and an ERC20 token address.
    """

    erc20_address: str = betterproto.string_field(1)
    """erc20_address is the hex address of ERC20 contract token"""

    denom: str = betterproto.string_field(2)
    """denom defines the cosmos base denomination to be mapped to"""

    enabled: bool = betterproto.bool_field(3)
    """enabled defines the token mapping enable status"""

    contract_owner: "Owner" = betterproto.enum_field(4)
    """
    contract_owner is the an ENUM specifying the type of ERC20 owner (0 invalid, 1
    ModuleAccount, 2 external address)
    """


@dataclass(eq=False, repr=False)
class RegisterCoinProposal(betterproto.Message):
    """
    Deprecated: RegisterCoinProposal is a gov Content type to register a token pair for
    a
    native Cosmos coin. We're keeping it to remove the existing proposals from
    store. After that, remove this message.
    NOTE: Keep this message for backwards compatibility on proposals query
    """

    title: str = betterproto.string_field(1)
    """title of the proposal"""

    description: str = betterproto.string_field(2)
    """description of the proposal"""

    metadata: List["___cosmos_bank_v1_beta1__.Metadata"] = betterproto.message_field(3)
    """metadata slice of the native Cosmos coins"""


@dataclass(eq=False, repr=False)
class ProposalMetadata(betterproto.Message):
    """
    Deprecated: ProposalMetadata is used to parse a slice of denom metadata and generate
    the RegisterCoinProposal content. We're keeping it to remove the existing proposals
    from
    store. After that, remove this message.
    """

    metadata: List["___cosmos_bank_v1_beta1__.Metadata"] = betterproto.message_field(1)
    """metadata slice of the native Cosmos coins"""


@dataclass(eq=False, repr=False)
class RegisterErc20Proposal(betterproto.Message):
    """
    Deprecated: RegisterERC20Proposal is a gov Content type to register a token pair for
    an
    ERC20 token.
    NOTE: Keep this message for backwards compatibility on proposals query
    """

    title: str = betterproto.string_field(1)
    """title of the proposal"""

    description: str = betterproto.string_field(2)
    """description of the proposal"""

    erc20_addresses: List[str] = betterproto.string_field(3)
    """erc20addresses is a slice of  ERC20 token contract addresses"""


@dataclass(eq=False, repr=False)
class ToggleTokenConversionProposal(betterproto.Message):
    """
    Deprecated: ToggleTokenConversionProposal is a gov Content type to toggle the
    conversion
    of a token pair.
    NOTE: Keep this message for backwards compatibility on proposals query
    """

    title: str = betterproto.string_field(1)
    """title of the proposal"""

    description: str = betterproto.string_field(2)
    """description of the proposal"""

    token: str = betterproto.string_field(3)
    """
    token identifier can be either the hex contract address of the ERC20 or the
    Cosmos base denomination
    """


@dataclass(eq=False, repr=False)
class EventRegisterPair(betterproto.Message):
    """EventRegisterPair is an event emitted when a coin is registered."""

    denom: str = betterproto.string_field(1)
    """denom is the coin's denomination."""

    erc20_address: str = betterproto.string_field(2)
    """erc20_address is the ERC20 contract address."""


@dataclass(eq=False, repr=False)
class EventToggleTokenConversion(betterproto.Message):
    """
    EventToggleTokenConversion is an event emitted when a coin's token conversion is
    toggled.
    """

    denom: str = betterproto.string_field(1)
    """denom is the coin's denomination."""

    erc20_address: str = betterproto.string_field(2)
    """erc20_address is the ERC20 contract address."""


@dataclass(eq=False, repr=False)
class EventConvertCoin(betterproto.Message):
    """EventConvertCoin is an event emitted when a coin is converted."""

    sender: str = betterproto.string_field(1)
    """sender is the sender's address."""

    receiver: str = betterproto.string_field(2)
    """receiver is the receiver's address."""

    amount: str = betterproto.string_field(3)
    """amount is the amount of coins to be converted."""

    denom: str = betterproto.string_field(4)
    """denom is the coin's denomination."""

    erc20_address: str = betterproto.string_field(5)
    """erc20_address is the ERC20 contract address."""


@dataclass(eq=False, repr=False)
class EventConvertErc20(betterproto.Message):
    """EventConvertERC20 is an event emitted when an ERC20 is converted."""

    sender: str = betterproto.string_field(1)
    """sender is the sender's address."""

    receiver: str = betterproto.string_field(2)
    """receiver is the receiver's address."""

    amount: str = betterproto.string_field(3)
    """amount is the amount of coins to be converted."""

    denom: str = betterproto.string_field(4)
    """denom is the coin's denomination."""

    contract_address: str = betterproto.string_field(5)
    """
    contract_address of an ERC20 token contract, that is registered in a token pair
    """


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the module's genesis state."""

    params: "Params" = betterproto.message_field(1)
    """params are the erc20 module parameters at genesis"""

    token_pairs: List["TokenPair"] = betterproto.message_field(2)
    """token_pairs is a slice of the registered token pairs at genesis"""


@dataclass(eq=False, repr=False)
class Params(betterproto.Message):
    """Params defines the erc20 module params"""

    enable_erc20: bool = betterproto.bool_field(1)
    """
    enable_erc20 is the parameter to enable the conversion of Cosmos coins <--> ERC20
    tokens.
    """

    native_precompiles: List[str] = betterproto.string_field(3)
    """
    native_precompiles defines the slice of hex addresses of the
    active precompiles that are used to interact with native staking coins as ERC20s
    """

    dynamic_precompiles: List[str] = betterproto.string_field(4)
    """
    dynamic_precompiles defines the slice of hex addresses of the
    active precompiles that are used to interact with Bank coins as ERC20s
    """


@dataclass(eq=False, repr=False)
class QueryTokenPairsRequest(betterproto.Message):
    """
    QueryTokenPairsRequest is the request type for the Query/TokenPairs RPC
    method.
    """

    pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryTokenPairsResponse(betterproto.Message):
    """
    QueryTokenPairsResponse is the response type for the Query/TokenPairs RPC
    method.
    """

    token_pairs: List["TokenPair"] = betterproto.message_field(1)
    """token_pairs is a slice of registered token pairs for the erc20 module"""

    pagination: "___cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )
    """pagination defines the pagination in the response."""


@dataclass(eq=False, repr=False)
class QueryTokenPairRequest(betterproto.Message):
    """QueryTokenPairRequest is the request type for the Query/TokenPair RPC method."""

    token: str = betterproto.string_field(1)
    """
    token identifier can be either the hex contract address of the ERC20 or the
    Cosmos base denomination
    """


@dataclass(eq=False, repr=False)
class QueryTokenPairResponse(betterproto.Message):
    """
    QueryTokenPairResponse is the response type for the Query/TokenPair RPC
    method.
    """

    token_pair: "TokenPair" = betterproto.message_field(1)
    """
    token_pairs returns the info about a registered token pair for the erc20 module
    """


@dataclass(eq=False, repr=False)
class QueryParamsRequest(betterproto.Message):
    """QueryParamsRequest is the request type for the Query/Params RPC method."""

    pass


@dataclass(eq=False, repr=False)
class QueryParamsResponse(betterproto.Message):
    """
    QueryParamsResponse is the response type for the Query/Params RPC
    method.
    """

    params: "Params" = betterproto.message_field(1)
    """params are the erc20 module parameters"""


@dataclass(eq=False, repr=False)
class MsgConvertErc20(betterproto.Message):
    """
    MsgConvertERC20 defines a Msg to convert a ERC20 token to a native Cosmos
    coin.
    """

    contract_address: str = betterproto.string_field(1)
    """
    contract_address of an ERC20 token contract, that is registered in a token pair
    """

    amount: str = betterproto.string_field(2)
    """amount of ERC20 tokens to convert"""

    receiver: str = betterproto.string_field(3)
    """receiver is the bech32 address to receive native Cosmos coins"""

    sender: str = betterproto.string_field(4)
    """sender is the hex address from the owner of the given ERC20 tokens"""


@dataclass(eq=False, repr=False)
class MsgConvertErc20Response(betterproto.Message):
    """MsgConvertERC20Response returns no fields"""

    pass


@dataclass(eq=False, repr=False)
class MsgConvertCoin(betterproto.Message):
    """MsgConvertCoin defines a Msg to convert a native Cosmos coin to a ERC20 token"""

    coin: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(1)
    """
    coin is a Cosmos coin whose denomination is registered in a token pair. The coin
    amount defines the amount of coins to convert.
    """

    receiver: str = betterproto.string_field(2)
    """receiver is the hex address to receive ERC20 token"""

    sender: str = betterproto.string_field(3)
    """sender is the cosmos bech32 address from the owner of the given Cosmos coins"""


@dataclass(eq=False, repr=False)
class MsgConvertCoinResponse(betterproto.Message):
    """MsgConvertCoinResponse returns no fields"""

    pass


@dataclass(eq=False, repr=False)
class MsgUpdateParams(betterproto.Message):
    """
    MsgUpdateParams is the Msg/UpdateParams request type for Erc20 parameters.
    Since: cosmos-sdk 0.47
    """

    authority: str = betterproto.string_field(1)
    """authority is the address of the governance account."""

    params: "Params" = betterproto.message_field(2)
    """
    params defines the x/evm parameters to update.
    NOTE: All parameters must be supplied.
    """


@dataclass(eq=False, repr=False)
class MsgUpdateParamsResponse(betterproto.Message):
    """
    MsgUpdateParamsResponse defines the response structure for executing a
    MsgUpdateParams message.
    Since: cosmos-sdk 0.47
    """

    pass


@dataclass(eq=False, repr=False)
class MsgRegisterErc20(betterproto.Message):
    """
    MsgRegisterERC20 is the Msg/RegisterERC20 request type for registering
    an Erc20 contract token pair.
    """

    authority: str = betterproto.string_field(1)
    """authority is the address of the governance account."""

    erc20_addresses: List[str] = betterproto.string_field(2)
    """erc20addresses is a slice of ERC20 token contract hex addresses"""


@dataclass(eq=False, repr=False)
class MsgRegisterErc20Response(betterproto.Message):
    """
    MsgRegisterERC20Response defines the response structure for executing a
    MsgRegisterERC20 message.
    """

    pass


@dataclass(eq=False, repr=False)
class MsgToggleConversion(betterproto.Message):
    """
    MsgToggleConversion is the Msg/MsgToggleConversion request type for toggling
    an Erc20 contract conversion capability.
    """

    authority: str = betterproto.string_field(1)
    """authority is the address of the governance account."""

    token: str = betterproto.string_field(2)
    """
    token identifier can be either the hex contract address of the ERC20 or the
    Cosmos base denomination
    """


@dataclass(eq=False, repr=False)
class MsgToggleConversionResponse(betterproto.Message):
    """
    MsgToggleConversionResponse defines the response structure for executing a
    ToggleConversion message.
    """

    pass


class QueryStub(betterproto.ServiceStub):
    async def token_pairs(
        self,
        query_token_pairs_request: "QueryTokenPairsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "QueryTokenPairsResponse":
        return await self._unary_unary(
            "/evmos.erc20.v1.Query/TokenPairs",
            query_token_pairs_request,
            QueryTokenPairsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def token_pair(
        self,
        query_token_pair_request: "QueryTokenPairRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "QueryTokenPairResponse":
        return await self._unary_unary(
            "/evmos.erc20.v1.Query/TokenPair",
            query_token_pair_request,
            QueryTokenPairResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def params(
        self,
        query_params_request: "QueryParamsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "QueryParamsResponse":
        return await self._unary_unary(
            "/evmos.erc20.v1.Query/Params",
            query_params_request,
            QueryParamsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class MsgStub(betterproto.ServiceStub):
    async def convert_erc20(
        self,
        msg_convert_erc20: "MsgConvertErc20",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "MsgConvertErc20Response":
        return await self._unary_unary(
            "/evmos.erc20.v1.Msg/ConvertERC20",
            msg_convert_erc20,
            MsgConvertErc20Response,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_params(
        self,
        msg_update_params: "MsgUpdateParams",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "MsgUpdateParamsResponse":
        return await self._unary_unary(
            "/evmos.erc20.v1.Msg/UpdateParams",
            msg_update_params,
            MsgUpdateParamsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def register_erc20(
        self,
        msg_register_erc20: "MsgRegisterErc20",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "MsgRegisterErc20Response":
        return await self._unary_unary(
            "/evmos.erc20.v1.Msg/RegisterERC20",
            msg_register_erc20,
            MsgRegisterErc20Response,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def toggle_conversion(
        self,
        msg_toggle_conversion: "MsgToggleConversion",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "MsgToggleConversionResponse":
        return await self._unary_unary(
            "/evmos.erc20.v1.Msg/ToggleConversion",
            msg_toggle_conversion,
            MsgToggleConversionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class QueryBase(ServiceBase):
    async def token_pairs(
        self, query_token_pairs_request: "QueryTokenPairsRequest"
    ) -> "QueryTokenPairsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def token_pair(
        self, query_token_pair_request: "QueryTokenPairRequest"
    ) -> "QueryTokenPairResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def params(
        self, query_params_request: "QueryParamsRequest"
    ) -> "QueryParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_token_pairs(
        self,
        stream: "grpclib.server.Stream[QueryTokenPairsRequest, QueryTokenPairsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.token_pairs(request)
        await stream.send_message(response)

    async def __rpc_token_pair(
        self,
        stream: "grpclib.server.Stream[QueryTokenPairRequest, QueryTokenPairResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.token_pair(request)
        await stream.send_message(response)

    async def __rpc_params(
        self, stream: "grpclib.server.Stream[QueryParamsRequest, QueryParamsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.params(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/evmos.erc20.v1.Query/TokenPairs": grpclib.const.Handler(
                self.__rpc_token_pairs,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryTokenPairsRequest,
                QueryTokenPairsResponse,
            ),
            "/evmos.erc20.v1.Query/TokenPair": grpclib.const.Handler(
                self.__rpc_token_pair,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryTokenPairRequest,
                QueryTokenPairResponse,
            ),
            "/evmos.erc20.v1.Query/Params": grpclib.const.Handler(
                self.__rpc_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryParamsRequest,
                QueryParamsResponse,
            ),
        }


class MsgBase(ServiceBase):
    async def convert_erc20(
        self, msg_convert_erc20: "MsgConvertErc20"
    ) -> "MsgConvertErc20Response":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_params(
        self, msg_update_params: "MsgUpdateParams"
    ) -> "MsgUpdateParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def register_erc20(
        self, msg_register_erc20: "MsgRegisterErc20"
    ) -> "MsgRegisterErc20Response":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def toggle_conversion(
        self, msg_toggle_conversion: "MsgToggleConversion"
    ) -> "MsgToggleConversionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_convert_erc20(
        self, stream: "grpclib.server.Stream[MsgConvertErc20, MsgConvertErc20Response]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.convert_erc20(request)
        await stream.send_message(response)

    async def __rpc_update_params(
        self, stream: "grpclib.server.Stream[MsgUpdateParams, MsgUpdateParamsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_params(request)
        await stream.send_message(response)

    async def __rpc_register_erc20(
        self,
        stream: "grpclib.server.Stream[MsgRegisterErc20, MsgRegisterErc20Response]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.register_erc20(request)
        await stream.send_message(response)

    async def __rpc_toggle_conversion(
        self,
        stream: "grpclib.server.Stream[MsgToggleConversion, MsgToggleConversionResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.toggle_conversion(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/evmos.erc20.v1.Msg/ConvertERC20": grpclib.const.Handler(
                self.__rpc_convert_erc20,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgConvertErc20,
                MsgConvertErc20Response,
            ),
            "/evmos.erc20.v1.Msg/UpdateParams": grpclib.const.Handler(
                self.__rpc_update_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateParams,
                MsgUpdateParamsResponse,
            ),
            "/evmos.erc20.v1.Msg/RegisterERC20": grpclib.const.Handler(
                self.__rpc_register_erc20,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgRegisterErc20,
                MsgRegisterErc20Response,
            ),
            "/evmos.erc20.v1.Msg/ToggleConversion": grpclib.const.Handler(
                self.__rpc_toggle_conversion,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgToggleConversion,
                MsgToggleConversionResponse,
            ),
        }
